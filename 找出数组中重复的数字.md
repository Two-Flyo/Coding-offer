## 找出数组中重复的数字

给定一个长度为 n 的整数数组 `nums`，数组中所有的数字都在 0∼n−10∼n−1 的范围内。

数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。

请找出数组中任意一个重复的数字。

**注意**：如果某些数字不在 `0∼n−1` 的范围内，或数组中不包含重复数字，则返回 -1；

### 数据范围

`0≤n≤10000≤n≤1000`

### 样例

```样例
给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。

返回 2 或 3。
```

### 题解

思路：**一个萝卜一个坑:`即该数组下标i应该等于num[i]`**，在给定的数组中，我们从下标0开始遍历，当该下标所存储的数`nums[i]`与该数对应的正确位置的数`num[nums[i]]`不相等时，即说明该数`nums[i]所处位置不满足"一个萝卜一个坑"`，故我们调整该数的位置使其位置正确，`while(num[i]!=nums[nums[i]]) swap(nums[i],nums[nums[i]])`，在循环的过程中，我们每次执行`swap(nums[i],nums[nums[i]])`的时候，**一定会有一个数被调整到正确位置上**。若给定数组为空，不会进入for循环，按照题意`return -1;`，或给定的数组中所有元素都不重复，则`for(int i=0;i<n;i++)`遍历完所有下标后，`if(nums[i]!=i) return nums[i];`都不会被执行，故循环结束后，按照题意`return -1;`，当数组给定的元素存在重复时，则一定会有数字`nums[i]`所处的位置不正确，即`nums[i]!=i`，造成该数字不正确的原因是该数字`nums[i]`对应正确位置`nums[nums[i]]`已经存储的对应正确的数字，这也是while循环结束的原因，则说明该数字是重复的，故我们返回该重复数字`return nums[i]`

**^\_^建议阅读完成思路后，用样例去手工模拟一下该过程以加深理解^\_^**

### 代码

```c++
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n=nums.size();
        for(auto x:nums)
            if(x<0||x>=n) return -1;//数字不在 `0∼n−1` 的范围内
        for(int i=0;i<n;i++)
        {
            while(nums[i]!=nums[nums[i]]) swap(nums[i],nums[nums[i]]);
            if(nums[i]!=i) return nums[i];
        }
        return -1;
        
    }
};															//lrf 2022/01/29 0:46
```

